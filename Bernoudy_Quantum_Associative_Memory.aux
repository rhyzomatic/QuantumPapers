\relax 
\citation{Ven00}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{1}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Explanation of Algorithms}{1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Overview}{1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Learning Stage}{1}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces This example is for loading patterns with a length of 3. The pattern would come in loaded on the classical bits, $y_1$, $y_2$ and $y_3$. The 0X gate represents a controlled NOT except that the control looks for a zero on $c2$.\relax }}{3}}
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{fig:digraph}{{1}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Recall algorithm}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces This example represents one pattern for $I_P$. The pattern would be (1 0 1), so we need to apply the NOT gate to the second qubit because it is a zero.\relax }}{3}}
\newlabel{fig:digraph2}{{2}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces This example would correspond to the partial sequence (0 1 ? ?). We apply a NOT gate to the first qubit because we know it is a zero, then a Z with controls on the known qubits with a target on one of the unkowns, and then re-apply the NOT.\relax }}{4}}
\newlabel{fig:digraph3}{{3}{4}}
